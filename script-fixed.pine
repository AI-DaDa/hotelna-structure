//@version=5
strategy("Advanced Multi-Pattern Detector PRO v2", overlay=true, max_labels_count=500, max_lines_count=500, max_boxes_count=500, default_qty_type=strategy.percent_of_equity, default_qty_value=10)

// ============================================================================
// INPUT SETTINGS
// ============================================================================
patternGroup = "Pattern Detection"
enableHeadShoulders = input.bool(true, "Head & Shoulders", group=patternGroup)
enableDoubleTop = input.bool(true, "Double Top", group=patternGroup)
enableDoubleBottom = input.bool(true, "Double Bottom", group=patternGroup)
enableTriangles = input.bool(true, "Triangles (Asc/Desc/Sym)", group=patternGroup)
enableWedges = input.bool(false, "Wedges (Rising/Falling)", group=patternGroup)
enableCupHandle = input.bool(true, "Cup & Handle", group=patternGroup)
enableRoundingBottom = input.bool(false, "Rounding Bottom", group=patternGroup)
enablePennants = input.bool(false, "Pennants/Flags", group=patternGroup)

sensitivityGroup = "Sensitivity Settings"
useAdaptive = input.bool(true, "Auto-Adjust for Timeframe", group=sensitivityGroup, tooltip="Automatically adjusts pivot lookback and pattern length based on current timeframe")
pivotLookback = input.int(5, "Pivot Lookback (Manual)", minval=3, maxval=50, group=sensitivityGroup)
patternLength = input.int(20, "Pattern Length (Manual)", minval=10, maxval=200, group=sensitivityGroup)
tolerance = input.float(2.0, "Price Tolerance %", minval=0.5, maxval=10.0, group=sensitivityGroup)
minPatternBars = input.int(5, "Min Bars Between Pivots", minval=2, maxval=50, group=sensitivityGroup)

// MULTI-TIMEFRAME ANALYSIS
mtfGroup = "Multi-Timeframe Analysis"
enableMTF = input.bool(true, "Enable MTF Confirmation", group=mtfGroup, tooltip="Check higher timeframe for trend confirmation")
htfMultiplier = input.int(4, "Higher TF Multiplier", minval=2, maxval=10, group=mtfGroup, tooltip="Multiplier for higher timeframe (e.g., 4 = check 4x current TF)")
showMTFTrend = input.bool(true, "Show HTF Trend Signal", group=mtfGroup)

// BREAKOUT DETECTION
breakoutGroup = "Breakout Detection"
enableBreakout = input.bool(true, "Enable Breakout Detection", group=breakoutGroup)
breakoutConfirmBars = input.int(2, "Breakout Confirmation Bars", minval=1, maxval=10, group=breakoutGroup)
breakoutVolThreshold = input.float(1.2, "Volume Threshold (x avg)", minval=1.0, maxval=3.0, group=breakoutGroup)
useRelativeVolume = input.bool(true, "Use Relative Volume", group=breakoutGroup, tooltip="Compare volume to recent average instead of fixed average")

// TARGET PRICE PROJECTION
targetGroup = "Target Price Projection"
enableTargets = input.bool(true, "Show Price Targets", group=targetGroup)
targetMethod = input.string("Pattern Height", "Target Method", options=["Pattern Height", "Fibonacci", "ATR Multiple"], group=targetGroup)
fibLevel = input.float(1.618, "Fibonacci Extension", minval=1.0, maxval=3.0, group=targetGroup)
atrMultiple = input.float(2.0, "ATR Multiple", minval=1.0, maxval=5.0, group=targetGroup)
showStopLoss = input.bool(true, "Show Stop Loss", group=targetGroup)

// STRATEGY SETTINGS
strategyGroup = "Strategy Settings"
enableStrategy = input.bool(false, "Enable Strategy Trades", group=strategyGroup)
riskPercent = input.float(2.0, "Risk % Per Trade", minval=0.5, maxval=10.0, group=strategyGroup)
riskRewardRatio = input.float(2.0, "Risk:Reward Ratio", minval=1.0, maxval=5.0, group=strategyGroup)
onlyTradeWithTrend = input.bool(true, "Only Trade With Trend", group=strategyGroup)
trendMaPeriod = input.int(50, "Trend MA Period", minval=20, maxval=200, group=strategyGroup)

visualGroup = "Visual Settings"
showLabels = input.bool(true, "Show Labels", group=visualGroup)
showLines = input.bool(true, "Show Pattern Lines", group=visualGroup)
showZones = input.bool(true, "Show Breakout Zones", group=visualGroup)
labelSize = input.string("small", "Label Size", options=["tiny", "small", "normal", "large"], group=visualGroup)
showConfidence = input.bool(true, "Show Confidence Score", group=visualGroup, tooltip="Display pattern quality score")
minConfidence = input.int(60, "Min Confidence %", minval=0, maxval=100, group=visualGroup, tooltip="Only show patterns above this confidence level")

// ============================================================================
// TIMEFRAME ADAPTATION
// ============================================================================
// Auto-detect timeframe and adjust parameters
getTimeframeMinutes() =>
    tf = timeframe.period
    multiplier = 1.0
    if str.contains(tf, "S")
        multiplier := 1.0 / 60.0
    else if str.contains(tf, "D")
        multiplier := 1440.0
    else if str.contains(tf, "W")
        multiplier := 10080.0
    else if str.contains(tf, "M")
        multiplier := 43200.0
    tfNum = str.tonumber(str.replace_all(str.replace_all(str.replace_all(str.replace_all(str.replace_all(tf, "S", ""), "D", ""), "W", ""), "M", ""), "H", ""))
    tfNum := na(tfNum) ? 1.0 : tfNum
    tfNum * multiplier

tfMinutes = getTimeframeMinutes()

// Adaptive parameters based on timeframe
adaptivePivotLookback = useAdaptive ?
     tfMinutes <= 5 ? 3 :      // 1m-5m: 3 bars
     tfMinutes <= 15 ? 5 :     // 15m: 5 bars
     tfMinutes <= 60 ? 7 :     // 1H: 7 bars
     tfMinutes <= 240 ? 10 :   // 4H: 10 bars
     tfMinutes <= 1440 ? 15 :  // Daily: 15 bars
     20 :                       // Weekly+: 20 bars
     pivotLookback

adaptivePatternLength = useAdaptive ?
     tfMinutes <= 5 ? 15 :     // 1m-5m: 15 bars
     tfMinutes <= 15 ? 20 :    // 15m: 20 bars
     tfMinutes <= 60 ? 30 :    // 1H: 30 bars
     tfMinutes <= 240 ? 50 :   // 4H: 50 bars
     tfMinutes <= 1440 ? 80 :  // Daily: 80 bars
     100 :                      // Weekly+: 100 bars
     patternLength

adaptiveVolPeriod = useAdaptive ?
     tfMinutes <= 5 ? 14 :     // 1m-5m: 14 bars
     tfMinutes <= 60 ? 20 :    // 15m-1H: 20 bars
     tfMinutes <= 1440 ? 30 :  // 4H-Daily: 30 bars
     50 :                       // Weekly+: 50 bars
     20

// ============================================================================
// GLOBAL VARIABLES
// ============================================================================
var float entryPrice = na
var float stopLoss = na
var float takeProfit = na
var string currentPattern = ""
var bool inTrade = false

// Trend Filter
trendMa = ta.sma(close, trendMaPeriod)
uptrend = close > trendMa
downtrend = close < trendMa

// Multi-Timeframe Trend
htfTimeframe = str.tostring(math.max(math.round(tfMinutes * htfMultiplier), 1))
htfClose = request.security(syminfo.tickerid, htfTimeframe, close, lookahead=barmerge.lookahead_off)
htfMa = request.security(syminfo.tickerid, htfTimeframe, ta.sma(close, trendMaPeriod), lookahead=barmerge.lookahead_off)
htfUptrend = htfClose > htfMa
htfDowntrend = htfClose < htfMa
mtfConfirmed = enableMTF ? (uptrend and htfUptrend) or (downtrend and htfDowntrend) : true

// Volume Analysis (Adaptive)
avgVolume = ta.sma(volume, adaptiveVolPeriod)
recentAvgVol = useRelativeVolume ? ta.sma(volume, math.round(adaptiveVolPeriod / 2)) : avgVolume
highVolume = volume > recentAvgVol * breakoutVolThreshold

// ATR for dynamic targets
atr = ta.atr(14)
atrPercent = (atr / close) * 100

// ============================================================================
// PIVOT DETECTION (Adaptive)
// ============================================================================
pivotHigh = ta.pivothigh(high, adaptivePivotLookback, adaptivePivotLookback)
pivotLow = ta.pivotlow(low, adaptivePivotLookback, adaptivePivotLookback)

var float[] highPivots = array.new_float(0)
var int[] highPivotBars = array.new_int(0)
var float[] lowPivots = array.new_float(0)
var int[] lowPivotBars = array.new_int(0)

if not na(pivotHigh)
    array.unshift(highPivots, pivotHigh)
    array.unshift(highPivotBars, bar_index - adaptivePivotLookback)
    if array.size(highPivots) > 100
        array.pop(highPivots)
        array.pop(highPivotBars)

if not na(pivotLow)
    array.unshift(lowPivots, pivotLow)
    array.unshift(lowPivotBars, bar_index - adaptivePivotLookback)
    if array.size(lowPivots) > 100
        array.pop(lowPivots)
        array.pop(lowPivotBars)

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================
priceWithinTolerance(float price1, float price2, float tolerancePct) =>
    diff = math.abs(price1 - price2)
    avgPrice = (price1 + price2) / 2
    (diff / avgPrice * 100) <= tolerancePct

// Calculate pattern confidence score (0-100)
calcConfidence(float priceMatch, int barDistance, bool volumeConfirm, bool trendAlign, bool mtfAlign) =>
    score = 0.0

    // Price symmetry (30 points)
    priceScore = priceMatch <= tolerance ? 30.0 : math.max(0, 30.0 - (priceMatch - tolerance) * 3)
    score := score + priceScore

    // Time symmetry (20 points)
    timeScore = barDistance <= adaptivePatternLength ? 20.0 : math.max(0, 20.0 - ((barDistance - adaptivePatternLength) / adaptivePatternLength) * 20)
    score := score + timeScore

    // Volume confirmation (20 points)
    score := score + (volumeConfirm ? 20.0 : 0.0)

    // Trend alignment (15 points)
    score := score + (trendAlign ? 15.0 : 0.0)

    // MTF alignment (15 points)
    score := score + (mtfAlign ? 15.0 : 0.0)

    math.min(100, math.max(0, score))

drawLabel(int barIdx, float price, string labelText, color col, string style, float confidence = na) =>
    if showLabels
        finalText = labelText
        if showConfidence and not na(confidence)
            finalText := labelText + "\n" + str.tostring(math.round(confidence)) + "%"
        label.new(barIdx, price, finalText, color=col, textcolor=color.white, style=style, size=labelSize)

drawLine(int x1, float y1, int x2, float y2, color col, string style=line.style_solid, int width=2) =>
    if showLines
        line.new(x1, y1, x2, y2, color=col, style=style, width=width)

drawBox(int left, float top, int right, float bottom, color borderCol, color bgCol) =>
    if showZones
        box.new(left, top, right, bottom, border_color=borderCol, bgcolor=bgCol, border_width=1)

// Calculate Target Price
calcTarget(string patternType, float entryLevel, float patternHeight, bool isBullish) =>
    target = 0.0
    if targetMethod == "Pattern Height"
        target := isBullish ? entryLevel + patternHeight : entryLevel - patternHeight
    else if targetMethod == "Fibonacci"
        target := isBullish ? entryLevel + (patternHeight * fibLevel) : entryLevel - (patternHeight * fibLevel)
    else if targetMethod == "ATR Multiple"
        target := isBullish ? entryLevel + (atr * atrMultiple) : entryLevel - (atr * atrMultiple)
    target

// Draw Target Projection
drawTargetProjection(int entryBar, float entryPrice, float targetPrice, float stopPrice, bool isBullish) =>
    if enableTargets
        // Entry line
        drawLine(entryBar, entryPrice, bar_index + 10, entryPrice, color.blue, line.style_dashed, 1)

        // Target line
        targetCol = isBullish ? color.new(color.green, 30) : color.new(color.red, 30)
        drawLine(entryBar, targetPrice, bar_index + 10, targetPrice, targetCol, line.style_solid, 2)

        // Stop loss line
        if showStopLoss
            stopCol = isBullish ? color.new(color.red, 30) : color.new(color.green, 30)
            drawLine(entryBar, stopPrice, bar_index + 10, stopPrice, stopCol, line.style_dotted, 1)

        // Target zone box
        boxTop = isBullish ? targetPrice : entryPrice
        boxBottom = isBullish ? entryPrice : targetPrice
        drawBox(entryBar, boxTop, bar_index + 10, boxBottom, targetCol, color.new(targetCol, 90))

        // Labels
        rrRatio = math.abs(targetPrice - entryPrice) / math.max(math.abs(entryPrice - stopPrice), 0.01)
        label.new(bar_index + 5, targetPrice, "TP: " + str.tostring(targetPrice, format.mintick) +
                 "\nR:R " + str.tostring(rrRatio, "#.##"),
                 color=targetCol, textcolor=color.white, style=label.style_label_left, size=size.tiny)

// ============================================================================
// PATTERN DETECTION FUNCTIONS
// ============================================================================

// HEAD & SHOULDERS
detectHeadShoulders() =>
    detected = false
    neckline = 0.0
    target = 0.0
    barIdx = 0
    confidence = 0.0

    if array.size(highPivots) >= 5 and array.size(lowPivots) >= 2
        h1 = array.get(highPivots, 4)
        h2 = array.get(highPivots, 2)
        h3 = array.get(highPivots, 0)

        n1 = array.get(lowPivots, 1)
        n2 = array.get(lowPivots, 0)

        h1Bar = array.get(highPivotBars, 4)
        h2Bar = array.get(highPivotBars, 2)
        h3Bar = array.get(highPivotBars, 0)

        if h2 > h1 and h2 > h3
            shoulderDiff = math.abs(h1 - h3) / h1 * 100
            neckDiff = math.abs(n1 - n2) / n1 * 100
            barDist = h3Bar - h1Bar

            if shoulderDiff <= tolerance * 1.5 and neckDiff <= tolerance and barDist >= minPatternBars
                neckline := (n1 + n2) / 2
                patternHeight = h2 - neckline

                // Calculate confidence
                avgDiff = (shoulderDiff + neckDiff) / 2
                // Use current bar volume as proxy since we can't use request.security in conditional
                volConfirm = highVolume
                trendAlign = downtrend or not onlyTradeWithTrend

                confidence := calcConfidence(avgDiff, barDist, volConfirm, trendAlign, htfDowntrend or not enableMTF)

                if confidence >= minConfidence
                    detected := true
                    target := calcTarget("H&S", neckline, patternHeight, false)
                    barIdx := h2Bar

                    if showLabels
                        drawLabel(barIdx, h2 * 1.02, "H&S\nâ†“ " + str.tostring(target, format.mintick), color.red, label.style_label_down, confidence)

                    // Draw neckline
                    neckBar1 = array.get(lowPivotBars, 1)
                    neckBar2 = array.get(lowPivotBars, 0)
                    drawLine(neckBar1, neckline, neckBar2 + 20, neckline, color.red, line.style_solid, 2)
    [detected, neckline, target, barIdx]

// DOUBLE TOP
detectDoubleTop() =>
    detected = false
    resistance = 0.0
    target = 0.0
    barIdx = 0
    confidence = 0.0

    if array.size(highPivots) >= 2 and array.size(lowPivots) >= 1
        peak1 = array.get(highPivots, 1)
        peak2 = array.get(highPivots, 0)
        valley = array.get(lowPivots, 0)

        bar1 = array.get(highPivotBars, 1)
        bar2 = array.get(highPivotBars, 0)
        barDist = bar2 - bar1

        peakDiff = math.abs(peak1 - peak2) / peak1 * 100

        if peakDiff <= tolerance and valley < peak1 * 0.98 and barDist < adaptivePatternLength and barDist >= minPatternBars
            resistance := (peak1 + peak2) / 2
            patternHeight = resistance - valley

            // Calculate confidence
            volConfirm = highVolume
            trendAlign = downtrend or not onlyTradeWithTrend

            confidence := calcConfidence(peakDiff, barDist, volConfirm, trendAlign, htfDowntrend or not enableMTF)

            if confidence >= minConfidence
                detected := true
                target := calcTarget("DT", valley, patternHeight, false)
                barIdx := bar2

                if showLabels
                    drawLabel(bar2, peak2 * 1.01, "DT\nâ†“ " + str.tostring(target, format.mintick), color.red, label.style_label_down, confidence)

                drawLine(bar1, resistance, bar2 + 20, resistance, color.red, line.style_solid, 2)
    [detected, resistance, target, barIdx]

// DOUBLE BOTTOM
detectDoubleBottom() =>
    detected = false
    support = 0.0
    target = 0.0
    barIdx = 0
    confidence = 0.0

    if array.size(lowPivots) >= 2 and array.size(highPivots) >= 1
        trough1 = array.get(lowPivots, 1)
        trough2 = array.get(lowPivots, 0)
        peak = array.get(highPivots, 0)

        bar1 = array.get(lowPivotBars, 1)
        bar2 = array.get(lowPivotBars, 0)
        barDist = bar2 - bar1

        troughDiff = math.abs(trough1 - trough2) / trough1 * 100

        if troughDiff <= tolerance and peak > trough1 * 1.02 and barDist < adaptivePatternLength and barDist >= minPatternBars
            support := (trough1 + trough2) / 2
            patternHeight = peak - support

            // Calculate confidence
            volConfirm = highVolume
            trendAlign = uptrend or not onlyTradeWithTrend

            confidence := calcConfidence(troughDiff, barDist, volConfirm, trendAlign, htfUptrend or not enableMTF)

            if confidence >= minConfidence
                detected := true
                target := calcTarget("DB", peak, patternHeight, true)
                barIdx := bar2

                if showLabels
                    drawLabel(bar2, trough2 * 0.99, "DB\nâ†‘ " + str.tostring(target, format.mintick), color.green, label.style_label_up, confidence)

                drawLine(bar1, support, bar2 + 20, support, color.green, line.style_solid, 2)
    [detected, support, target, barIdx]

// ASCENDING TRIANGLE
detectAscendingTriangle() =>
    detected = false
    resistance = 0.0
    target = 0.0
    barIdx = 0
    confidence = 0.0

    if array.size(highPivots) >= 3 and array.size(lowPivots) >= 2
        h1 = array.get(highPivots, 2)
        h2 = array.get(highPivots, 1)
        h3 = array.get(highPivots, 0)

        l1 = array.get(lowPivots, 1)
        l2 = array.get(lowPivots, 0)

        hBar1 = array.get(highPivotBars, 2)
        hBar3 = array.get(highPivotBars, 0)
        lBar1 = array.get(lowPivotBars, 1)
        lBar2 = array.get(lowPivotBars, 0)

        barDist = hBar3 - hBar1
        h1h2Diff = math.abs(h1 - h2) / h1 * 100
        h2h3Diff = math.abs(h2 - h3) / h2 * 100
        avgDiff = (h1h2Diff + h2h3Diff) / 2

        if avgDiff <= tolerance and l2 > l1 and barDist >= minPatternBars and barDist <= adaptivePatternLength
            resistance := (h1 + h2 + h3) / 3
            patternHeight = resistance - l1

            // Calculate confidence
            volConfirm = highVolume
            trendAlign = uptrend or not onlyTradeWithTrend

            confidence := calcConfidence(avgDiff, barDist, volConfirm, trendAlign, htfUptrend or not enableMTF)

            if confidence >= minConfidence
                detected := true
                target := calcTarget("ASC", resistance, patternHeight, true)
                barIdx := hBar3

                if showLabels
                    drawLabel(barIdx, h3 * 1.01, "â–²ASC\nâ†‘ " + str.tostring(target, format.mintick), color.green, label.style_label_down, confidence)

                drawLine(hBar1, resistance, hBar3 + 15, resistance, color.green, line.style_solid, 2)
                drawLine(lBar1, l1, lBar2, l2, color.green, line.style_solid, 2)
    [detected, resistance, target, barIdx]

// DESCENDING TRIANGLE
detectDescendingTriangle() =>
    detected = false
    support = 0.0
    target = 0.0
    barIdx = 0
    confidence = 0.0

    if array.size(lowPivots) >= 3 and array.size(highPivots) >= 2
        l1 = array.get(lowPivots, 2)
        l2 = array.get(lowPivots, 1)
        l3 = array.get(lowPivots, 0)

        h1 = array.get(highPivots, 1)
        h2 = array.get(highPivots, 0)

        lBar1 = array.get(lowPivotBars, 2)
        lBar3 = array.get(lowPivotBars, 0)
        hBar1 = array.get(highPivotBars, 1)
        hBar2 = array.get(highPivotBars, 0)

        barDist = lBar3 - lBar1
        l1l2Diff = math.abs(l1 - l2) / l1 * 100
        l2l3Diff = math.abs(l2 - l3) / l2 * 100
        avgDiff = (l1l2Diff + l2l3Diff) / 2

        if avgDiff <= tolerance and h2 < h1 and barDist >= minPatternBars and barDist <= adaptivePatternLength
            support := (l1 + l2 + l3) / 3
            patternHeight = h1 - support

            // Calculate confidence
            volConfirm = highVolume
            trendAlign = downtrend or not onlyTradeWithTrend

            confidence := calcConfidence(avgDiff, barDist, volConfirm, trendAlign, htfDowntrend or not enableMTF)

            if confidence >= minConfidence
                detected := true
                target := calcTarget("DESC", support, patternHeight, false)
                barIdx := lBar3

                if showLabels
                    drawLabel(barIdx, l3 * 0.99, "â–¼DESC\nâ†“ " + str.tostring(target, format.mintick), color.red, label.style_label_up, confidence)

                drawLine(lBar1, support, lBar3 + 15, support, color.red, line.style_solid, 2)
                drawLine(hBar1, h1, hBar2, h2, color.red, line.style_solid, 2)
    [detected, support, target, barIdx]

// CUP & HANDLE
detectCupHandle() =>
    detected = false
    target = 0.0
    barIdx = 0
    breakLevel = 0.0
    confidence = 0.0

    if array.size(lowPivots) >= 3 and array.size(highPivots) >= 2
        l1 = array.get(lowPivots, 2)
        l2 = array.get(lowPivots, 1)
        l3 = array.get(lowPivots, 0)
        h1 = array.get(highPivots, 1)

        lBar1 = array.get(lowPivotBars, 2)
        lBar3 = array.get(lowPivotBars, 0)
        barDist = lBar3 - lBar1

        if l2 < l1 * 0.95 and l2 < l3 * 0.98 and barDist >= minPatternBars
            if l3 > l2 and l3 < h1
                breakLevel := h1
                patternHeight = h1 - l2

                // Calculate confidence (cup depth and symmetry)
                cupDepth = (l1 - l2) / l1 * 100
                handleDepth = (l3 - l2) / l3 * 100
                symmetryScore = math.abs(cupDepth - handleDepth)

                volConfirm = highVolume
                trendAlign = uptrend or not onlyTradeWithTrend

                confidence := calcConfidence(symmetryScore, barDist, volConfirm, trendAlign, htfUptrend or not enableMTF)

                if confidence >= minConfidence
                    detected := true
                    target := calcTarget("C&H", h1, patternHeight, true)
                    barIdx := lBar3

                    if showLabels
                        drawLabel(barIdx, l3 * 0.98, "â˜•C&H\nâ†‘ " + str.tostring(target, format.mintick), color.green, label.style_label_up, confidence)
    [detected, breakLevel, target, barIdx]

// ============================================================================
// PATTERN EXECUTION
// ============================================================================

// Execute pattern detection
var hsDetected = false
var hsNeckline = 0.0
var hsTarget = 0.0
var hsBar = 0

var dtDetected = false
var dtResistance = 0.0
var dtTarget = 0.0
var dtBar = 0

var dbDetected = false
var dbSupport = 0.0
var dbTarget = 0.0
var dbBar = 0

var ascTriDetected = false
var ascTriResistance = 0.0
var ascTriTarget = 0.0
var ascTriBar = 0

var descTriDetected = false
var descTriSupport = 0.0
var descTriTarget = 0.0
var descTriBar = 0

var cupDetected = false
var cupBreak = 0.0
var cupTarget = 0.0
var cupBar = 0

// Head & Shoulders
if enableHeadShoulders
    [d1, v1, v2, v3] = detectHeadShoulders()
    if d1
        hsDetected := d1
        hsNeckline := v1
        hsTarget := v2
        hsBar := v3

// Double Top
if enableDoubleTop
    [d2, v4, v5, v6] = detectDoubleTop()
    if d2
        dtDetected := d2
        dtResistance := v4
        dtTarget := v5
        dtBar := v6

// Double Bottom
if enableDoubleBottom
    [d3, v7, v8, v9] = detectDoubleBottom()
    if d3
        dbDetected := d3
        dbSupport := v7
        dbTarget := v8
        dbBar := v9

// Triangles
if enableTriangles
    [d4, v10, v11, v12] = detectAscendingTriangle()
    if d4
        ascTriDetected := d4
        ascTriResistance := v10
        ascTriTarget := v11
        ascTriBar := v12

    [d5, v13, v14, v15] = detectDescendingTriangle()
    if d5
        descTriDetected := d5
        descTriSupport := v13
        descTriTarget := v14
        descTriBar := v15

// Cup & Handle
if enableCupHandle
    [d6, v16, v17, v18] = detectCupHandle()
    if d6
        cupDetected := d6
        cupBreak := v16
        cupTarget := v17
        cupBar := v18

// ============================================================================
// STRATEGY EXECUTION
// ============================================================================
if enableStrategy
    // Double Bottom Breakout
    if dbDetected and strategy.position_size == 0
        if close > dbSupport * 1.02 and highVolume
            if onlyTradeWithTrend == false or uptrend
                entry = close
                stop = dbSupport * 0.98
                take = dbTarget

                posSize = strategy.equity * riskPercent / 100 / math.abs(entry - stop)
                strategy.entry("DB Long", strategy.long, qty=posSize)
                strategy.exit("DB Exit", "DB Long", stop=stop, limit=take)
                drawTargetProjection(bar_index, entry, take, stop, true)

    // Ascending Triangle Breakout
    if ascTriDetected and strategy.position_size == 0
        if close > ascTriResistance and highVolume
            if onlyTradeWithTrend == false or uptrend
                entry = close
                stop = ascTriResistance * 0.98
                take = ascTriTarget

                posSize = strategy.equity * riskPercent / 100 / math.abs(entry - stop)
                strategy.entry("ASC Long", strategy.long, qty=posSize)
                strategy.exit("ASC Exit", "ASC Long", stop=stop, limit=take)
                drawTargetProjection(bar_index, entry, take, stop, true)

// ============================================================================
// TREND INDICATOR
// ============================================================================
plot(trendMa, "Trend MA", color=uptrend ? color.green : color.red, linewidth=2)

// Show HTF Trend Signal
if showMTFTrend and barstate.islast
    var table mtfTable = table.new(position.top_right, 2, 2, border_width=1, border_color=color.gray, frame_color=color.new(color.blue, 80), frame_width=1)

    table.cell(mtfTable, 0, 0, "HTF (" + htfTimeframe + ")", text_color=color.white, bgcolor=color.new(color.blue, 50), text_size=size.small)
    htfColor = htfUptrend ? color.new(color.green, 50) : color.new(color.red, 50)
    htfText = htfUptrend ? "BULLISH â†‘" : "BEARISH â†“"
    table.cell(mtfTable, 1, 0, htfText, text_color=color.white, bgcolor=htfColor, text_size=size.small)

    table.cell(mtfTable, 0, 1, "Current TF", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small)
    ctfColor = uptrend ? color.new(color.green, 50) : color.new(color.red, 50)
    ctfText = uptrend ? "BULLISH â†‘" : "BEARISH â†“"
    table.cell(mtfTable, 1, 1, ctfText, text_color=color.white, bgcolor=ctfColor, text_size=size.small)

// ============================================================================
// PERFORMANCE DASHBOARD
// ============================================================================
if barstate.islast and enableStrategy
    var table dashboard = table.new(position.bottom_right, 3, 8, border_width=2, border_color=color.gray, frame_color=color.new(color.blue, 70), frame_width=2)

    table.cell(dashboard, 0, 0, "ðŸ“Š PERFORMANCE", text_color=color.white, bgcolor=color.new(color.blue, 30), text_size=size.normal)
    table.merge_cells(dashboard, 0, 0, 2, 0)

    table.cell(dashboard, 0, 1, "Metric", text_color=color.white, bgcolor=color.new(color.gray, 50))
    table.cell(dashboard, 1, 1, "Value", text_color=color.white, bgcolor=color.new(color.gray, 50))
    table.cell(dashboard, 2, 1, "Status", text_color=color.white, bgcolor=color.new(color.gray, 50))

    netProfit = strategy.netprofit
    totalTrades = strategy.closedtrades
    winRate = totalTrades > 0 ? strategy.wintrades / totalTrades * 100 : 0
    profitFactor = strategy.grossloss > 0 ? strategy.grossprofit / strategy.grossloss : 0

    table.cell(dashboard, 0, 2, "Net Profit", text_color=color.white)
    table.cell(dashboard, 1, 2, str.tostring(netProfit, format.mintick), text_color=netProfit > 0 ? color.lime : color.red)
    table.cell(dashboard, 2, 2, netProfit > 0 ? "âœ“" : "âœ—", text_color=netProfit > 0 ? color.lime : color.red, text_size=size.large)

    table.cell(dashboard, 0, 3, "Win Rate", text_color=color.white)
    table.cell(dashboard, 1, 3, str.tostring(winRate, "#.##") + "%", text_color=winRate > 50 ? color.lime : color.orange)
    table.cell(dashboard, 2, 3, winRate > 50 ? "âœ“" : "~", text_color=winRate > 50 ? color.lime : color.orange, text_size=size.large)

    table.cell(dashboard, 0, 4, "Profit Factor", text_color=color.white)
    table.cell(dashboard, 1, 4, str.tostring(profitFactor, "#.##"), text_color=profitFactor > 1.5 ? color.lime : color.orange)
    table.cell(dashboard, 2, 4, profitFactor > 1.5 ? "âœ“" : "~", text_color=profitFactor > 1.5 ? color.lime : color.orange, text_size=size.large)

    table.cell(dashboard, 0, 5, "Total Trades", text_color=color.white)
    table.cell(dashboard, 1, 5, str.tostring(totalTrades), text_color=color.yellow)
    table.cell(dashboard, 2, 5, "ðŸ“ˆ", text_color=color.yellow, text_size=size.large)

    table.cell(dashboard, 0, 6, "Wins / Losses", text_color=color.white)
    table.cell(dashboard, 1, 6, str.tostring(strategy.wintrades) + " / " + str.tostring(strategy.losstrades), text_color=color.white)
    table.cell(dashboard, 2, 6, "", text_color=color.white)

    table.cell(dashboard, 0, 7, "Max Drawdown", text_color=color.white)
    table.cell(dashboard, 1, 7, str.tostring(strategy.max_drawdown, format.mintick), text_color=color.red)
    table.cell(dashboard, 2, 7, "âš ", text_color=color.red, text_size=size.large)
